= dm-rest-adapter

A DataMapper adapter for REST Web Services

== Usage

DM Rest Adapter provides a way to fetch and update resources from the web
using the same DataMapper Resource classes you use when working with a
database, or another repository backend.  The only difference is that you will
use the Rest Adapter on your REST Resources.

The currently supported web formats are XML and JSON.

For example, using the default configuration, a resource at "/posts/1.xml" can
be fetched simply by using:

 post = Post.get(1) # => GET /posts/1.xml
 post.title         # => "A RESTful resource"
 
 post.title = "A new title"
 post.save          # => PUT /posts/1.xml
 
If the resource does not exist, nil is returned, or
DataMapper::ObjectNotFoundError is raised if #get! was used to fetch the
Resource.

The following is an example of a Post model using XML, where the host settings
simply point to localhost. In addition I have included a basic auth login
which will be used if your REST service requires authentication:

 DataMapper.setup(:default, {
   :adapter  => 'rest',
   :format   => 'xml',
   :host     => 'localhost',
   :port     => 4000,
   :login    => 'user',
   :password => 'verys3crit'
 })

 class Post
   include DataMapper::Resource

   property :id,    Serial
   property :title, String
   property :body,  Text
 end


If you notice this looks exactly like a normal datamapper model. Every property
you define will map itself with the xml returned or posted from/to the resource.

== Code

Now for some code examples. DM Rest Adapter uses the same methods as datamapper
including during creation.  You can still add validations and all the usual
DataMapper niceties to your models.

 Post.first
 # => returns the object from the resource
 Post.get(1)
 # => returns the object from the resource
 p = Post.new(
   :title => "My awesome blog post",
   :body  => "I really have nothing to say..."
 )
 p.save
 # => saves the resource on the remote

== Additional Configuration

You can specify a non-standard extension (i.e. something other than ".json" or
".xml") by passing the :extension option when setting up the connection.

 DataMapper.setup(:default, {
   :adapter   => 'rest',
   :format    => 'xml',
   :extension => 'anything',
   ...
 })

If your URLs have no extension on them, pass an empty string, or nil.

If your Resources map to a different path than the name of the model itself,
you can specify the path fragment with #storage_names as with other adapters:

 class Post
   include DataMapper::Resource
   
   storage_names[:default] = 'blog-posts'
   
   ...
 end

 Post.get(1)  #=> GET /blog-posts/1.json
 
Likewise, if the fields in the XML/JSON are not the same as the attributes in
your model, you can specify them with the :field option on your properties:

 class Post
   include DataMapper::Resource
   
   property :id,  Serial,  :field => 'post_id'
 end

== Nested Resources

DataMapper REST Adapter has support for nested URL structures, where child
relationships may be found nested under their parents in the URL.  Take for
example, fetching the comments from a Post:

 /posts/1/comments.json

We can set this up as follows:

 class Post
   include DataMapper::Resource

   property :id,    Serial
   property :title, String
   property :body,  Text
   
   has n, :comments, :nested => true
 end
 
 class Comment
   include DataMapper::Resource
   
   property :id,    Serial
   property :body,  String
   
   belongs_to :post
 end
 
 post = Post.get!(1)       # => /posts/1.json
 comments = post.comments  # => /posts/1/comments.json
 
DataMapper REST Adapter adds the :nested option to associations.  Setting this
to true will fetch the resource(s) at a subpath of the URL from which the parent
resource was loaded.

== Exercise Caution

RESTful web services, while convenient, are not known for being fast to query.
For example,
  
 Post.first

actually fetches all Posts and then returns the first of the collection.  There
is not much that can be done about this and it just comes down to using the
right tool for the job.

== Expected Formats for Legacy Applications

Work is scheduled to overcome this current limitation.  The currently expected
formats are:

=== XML

For a collection of Posts, the XML must adhere to a format like this:

 <posts>
   <post>
     <id type="integer">1</id>
     <created_at type="datetime">2011-06-16T02:38:42-07:00</created_at>
     <title>An awesome blog post</title>
   </post>
   <post>
     <id type="integer">2</id>
     ....
 </posts>
 
For a single Post:

 <post>
   <id type="integer">1</id>
   <created_at type="datetime">2011-06-16T02:38:42-07:00</created_at>
   <title>An awesome blog post</title>
 </post>

The type attributes are ignored by DM Rest Adapter and typecasting is done by
the properties on the model as usual, so the values are somewhat flexible.

=== JSON

For a collection of Posts, the JSON must adhere to a format like this:

 [
   {
     "id" : 1,
     "created_at" : "2011-06-16T02:38:42-07:00",
     "title" : "An awesome blog post"
   },
   {
     "id" : 2,
     ...
   }
 ]
 
For a single Post:

 {
   "id" : 1,
   "created_at" : "2011-06-16T02:38:42-07:00",
   "title" : "An awesome blog post"
 }

As with the XML format, the values themselves will be type-cast by the
properties on your model.

== TODO:

 * Nested resources.
 * Better support for associations.
 * More flexible formatting conventions.
 * Request Logging.
